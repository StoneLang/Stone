#ifndef STONE_SYNTAX_DECL_H
#define STONE_SYNTAX_DECL_H

#include "stone/Basic/AddressSpace.h"
#include "stone/Basic/LLVM.h"
#include "stone/Basic/SrcLoc.h"
#include "stone/Syntax/DeclContext.h"
#include "stone/Syntax/DeclName.h"
#include "stone/Syntax/Identifier.h"
#include "stone/Syntax/Node.h"
#include "stone/Syntax/Specifier.h"
#include "stone/Syntax/Type.h"

#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/PointerIntPair.h"
#include "llvm/ADT/PointerUnion.h"
#include "llvm/ADT/iterator.h"
#include "llvm/ADT/iterator_range.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/PrettyStackTrace.h"
#include "llvm/Support/VersionTuple.h"

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <iterator>
#include <string>
#include <type_traits>
#include <utility>

namespace stone {
namespace syn {

class Decl;
class Stmt;
class Module;
class BraceStmt;
class DeclContext;
class TreeContext;
class DeclFactory;

class DeclStats final : public Stats {
  const Decl &declaration;

public:
  DeclStats(const Decl &declaration, Basic &basic)
      : Stats("ast-declaration stats:", basic), declaration(declaration) {}
  void Print() override;
};

class alignas(8) Decl : public syn::Node {
public:
  enum Type {
    None,
#define DECL(Id, Parent) Id,
#define LAST_DECL(Id) LastDecl = Id,
#define DECL_RANGE(Id, FirstId, LastId)                                        \
  First##Id##Decl = FirstId, Last##Id##Decl = LastId,
#include "stone/Syntax/DeclType.def"
  };

private:
  friend DeclStats;

  Decl::Type ty;
  SrcLoc loc;
  DeclContext *dc;

public:
  // Make vanilla new/delete illegal for Decls.
  void *operator new(size_t bytes) = delete;
  void operator delete(void *data) = delete;

  // Only allow allocation of Decls using the allocator in ASTContext
  // or by doing a placement new.
  void *operator new(size_t bytes, const TreeContext &tc,
                     unsigned alignment = alignof(Decl));

  // TODO: UB
  void *operator new(std::size_t size, const TreeContext &ctx,
                     DeclContext *parent, std::size_t extra = 0);

public:
  Decl() = delete;
  Decl(const Decl &) = delete;
  Decl(Decl &&) = delete;
  Decl &operator=(const Decl &) = delete;
  Decl &operator=(Decl &&) = delete;

public:
  friend class DeclContext;

  struct MultipleDeclContext final {
    DeclContext *semaDeclContext;
    DeclContext *lexicalDeclContext;
  };

  llvm::PointerUnion<DeclContext *, MultipleDeclContext *> declCtx;

  bool IsInSemaDeclContext() const { return declCtx.is<DeclContext *>(); }
  bool IsOutOfSemaDeclContext() const {
    return declCtx.is<MultipleDeclContext *>();
  }

  MultipleDeclContext *GetMultipleDeclContext() const {
    return declCtx.get<MultipleDeclContext *>();
  }

  DeclContext *GetSemaDeclContext() const {
    return declCtx.get<DeclContext *>();
  }

  /// DeclKind - This indicates which class this is.
  // unsigned declType : 7;

  /// InvalidDecl - This indicates a semantic error occurred.
  // unsigned invalidDecl :  1;

  /// HasAttrs - This indicates whether the decl has attributes or not.
  // unsigned hasAttrs : 1;

  /// Implicit - Whether this declaration was implicitly generated by
  /// the implementation rather than explicitly written by the user.
  // unsigned implicit : 1;

  /// Whether this declaration was "used", meaning that a definition is
  /// required.
  // unsigned used : 1;

public:
  Decl::Type GetType() { return ty; }

  TreeContext &GetTreeContext() const LLVM_READONLY;

  /*
    const TreeContext &GetTreeContext() const {
      auto DC = context.dyn_cast<DeclContext *>();
      if (DC) {
        return DC->GetASTContext();
      }
      return *context.get<ASTContext *>();
    }

  */
protected:
  Decl(Decl::Type ty, DeclContext *dc, SrcLoc loc) : ty(ty), dc(dc), loc(loc) {}

public:
  template <typename DeclTy, typename AllocatorTy>
  static void *Allocate(AllocatorTy &allocatorTy, size_t baseSize) {
    return Allocate(allocatorTy, baseSize, false);
  }

  /// \param extraSpace The amount of extra space to allocate after the object
  /// -- generally for clang nodes.
  template <typename DeclTy, typename AllocatorTy>
  static void *Allocate(AllocatorTy &allocatorTy, size_t baseSize,
                        bool extraSpace);
};

class DeclContext {

public:
  enum class Type : unsigned {
    Decl,
    Expr,
    File,
  };

private:
  Decl::Type dTy;
  DeclContext::Type dcTy;

  DeclContext *parent;

protected:
  /// This anonymous union stores the bits belonging to DeclContext and classes
  /// deriving from it. The goal is to use otherwise wasted
  /// space in DeclContext to store data belonging to derived classes.
  /// The space saved is especially significient when pointers are aligned
  /// to 8 bytes. In this case due to alignment requirements we have a
  /// little less than 8 bytes free in DeclContext which we can use.
  /// We check that none of the classes in this union is larger than
  /// 8 bytes with static_asserts in the ctor of DeclContext.
  union {
    DeclContextBits declContextBits;
    NominalTypeDeclBits nominalTypeDeclBits;
    // EnumDeclBitfields EnumDeclBits;
    // RecordDeclBitfields RecordDeclBits;
    FunctionDeclBits functionDeclBits;
    // ConstructorDeclBits constructorDeclBits;
    // LinkageSpecDeclBitfields LinkageSpecDeclBits;
    // BlockDeclBitfields BlockDeclBits;

    ModuleDeclBits moduleDeclBits;

    static_assert(sizeof(DeclContextBits) <= 8,
                  "DeclContextBitfields is larger than 8 bytes!");

    static_assert(sizeof(NominalTypeDeclBits) <= 8,
                  "TagDeclBitfields is larger than 8 bytes!");

    // static_assert(sizeof(EnumDeclBits) <= 8,
    //              "EnumDeclBitfields is larger than 8 bytes!");
    // static_assert(sizeof(RecordDeclBits) <= 8,
    //              "RecordDeclBitfields is larger than 8 bytes!");
    static_assert(sizeof(FunctionDeclBits) <= 8,
                  "FunctionDeclBitfields is larger than 8 bytes!");

    static_assert(sizeof(ModuleDeclBits) <= 8,
                  "ModuleDeclBitfields is larger than 8 bytes!");

    // static_assert(sizeof(ConstructorDeclBits) <= 8,
    //              "ConstructorDeclBitfields is larger than 8 bytes!");
    // static_assert(sizeof(LinkageSpecDeclBits) <= 8,
    //              "LinkageSpecDeclBitfields is larger than 8 bytes!");
    // static_assert(sizeof(BlockDeclBitfields) <= 8,
    //              "BlockDeclBitfields is larger than 8 bytes!");
  };

protected:
  /// FirstDecl - The first declaration stored within this declaration
  /// context.
  mutable Decl *firstDecl = nullptr;

  /// LastDecl - The last declaration stored within this declaration
  /// context. FIXME: We could probably cache this value somewhere
  /// outside of the DeclContext, to reduce the size of DeclContext by
  /// another pointer.
  mutable Decl *lastDecl = nullptr;

  /// Build up a chain of declarations.
  ///
  /// \returns the first/last pair of declarations.
  static std::pair<Decl *, Decl *> BuildDeclChain(llvm::ArrayRef<Decl *> decls,
                                                  bool fieldsAlreadyLoaded);

public:
  DeclContext(DeclContext::Type dcTy, Decl::Type dTy,
              DeclContext *parent = nullptr);

public:
  Decl::Type GetDeclType() { return dTy; }
  DeclContext::Type GetDeclContextType() { return dcTy; }
  DeclContext *GetParent() { return parent; }

  Decl *GetAsDecl() {
    switch (dcTy) {
    case DeclContext::Type::Decl:
      return reinterpret_cast<Decl *>(this + 1); // TODO: UB
    default:
      return nullptr;
    }
  }
  const Decl *GetAsDecl() const {
    return const_cast<DeclContext *>(this)->GetAsDecl();
  }
};

class NamingDecl : public Decl {
  /// The name of this declaration, which is typically a normal
  /// identifier but may also be a special ty of name (C++
  /// constructor, etc.)
  DeclName name;

protected:
  NamingDecl(Decl::Type ty, DeclContext *dc, SrcLoc loc, DeclName name)
      : Decl(ty, dc, loc), name(name) {}

public:
  /// Get the identifier that names this declaration, if there is one.
  ///
  /// This will return NULL if this declaration has no name (e.g., for
  /// an unnamed class) or if the name is a special name such ast a C++
  /// constructor.
  Identifier *GetIdentifier() const { return name.GetAsIdentifier(); }

  /// Get the name of identifier for this declaration as a StringRef.
  ///
  /// This requires that the declaration have a name and that it be a simple
  /// identifier.
  llvm::StringRef GetName() const {
    // TODO: assert(name.IsIdentifier() && "Name is not a simple identifier");
    return GetIdentifier() ? GetIdentifier()->GetName() : "";
  }

public:
  void SetDeclName(DeclName name) { this->name = name; }
  // DeclName loc
  void SetLoc(SrcLoc loc) {}
};

class TypeDecl : public NamingDecl {

  friend class TreeContext;
  /// This indicates the Type object that represents
  /// this TypeDecl.  It is a cache maintained by
  /// ASTContext::getTypedefType, ASTContext::getTagDeclType, and
  /// ASTContext::getTemplateTypeParmType, and TemplateTypeParmDecl.
  // mutable const Type *TypeForDecl = nullptr;

  /// The start of the source range for this declaration.
  SrcLoc startLoc;

protected:
  TypeDecl(Decl::Type ty, DeclContext *dc, SrcLoc loc, Identifier *name,
           SrcLoc startLocation = SrcLoc())
      : NamingDecl(ty, dc, loc, name), startLoc(startLocation) {}
};

// TODO: May use this instead of using NamingDecl
class ValueDecl : public NamingDecl {
public:
};

class LabelDecl : public NamingDecl {
public:
};

class SpaceDecl : public NamingDecl {
public:
  SpaceDecl(DeclContext *dc, SrcLoc loc, DeclName name)
      : NamingDecl(Decl::Type::Space, dc, loc, name) {}
};

class DeclaratorDecl : public ValueDecl {
public:
};

// This is really your function prototye
class FunctionDecl : public DeclaratorDecl,
                     public DeclContext /*, syn::Redeclarable<FunctionDecl> */ {
public:
  FunctionDecl(Decl::Type ty, TreeContext &tc, DeclContext *dc,
               const DeclName &dn, SrcLoc dnLoc, StorageType st);

public:
  /// BraceStmt
  Stmt *GetBody();

  //void SetBody(Stmt body) {}

public:
};

/// Standalone function: fun F0() -> void {}
class FunDecl : public FunctionDecl {

  // TODO: You should aonly pass TreeContext and DeclContext
public:
  FunDecl(TreeContext &tc, DeclContext *dc, SrcLoc funLoc, const DeclName &dn,
          SrcLoc dnLoc, StorageType st)
      : FunctionDecl(Decl::Type::Fun, tc, dc, dn, dnLoc, st) {}

public:
  bool IsMain() const;

  /// True if the function is a defer body.
  bool IsDeferBody() const;

  void SetFunLoc(SrcLoc loc) {}

  // SrcLoc GetStaticLoc() const { return staticLoc; }
  // SrcLoc GetFunLoc() const { return funcLoc; }
};

// Member functions: fun Particle::Fire() -> bool ...
class MethodDecl : public FunctionDecl {
public:
  MethodDecl(TreeContext &tc, DeclContext *dc, SrcLoc funLoc,
             const DeclName &dn, SrcLoc dnLoc, StorageType st)
      : FunctionDecl(Decl::Type::Fun, tc, dc, dn, dnLoc, st) {}

public:
  bool IsStatic() const;
  bool IsInstance() const { return !IsStatic(); }
};

class NominalTypeDecl : public TypeDecl, public DeclContext {

public:
};

class StructDecl final : public NominalTypeDecl {
public:
};

class EnumDecl final : public NominalTypeDecl {
public:
};

class BlockDecl : public Decl, public DeclContext {};

class ConstructorInitializer final {
public:
};

class ConstructorDecl : public MethodDecl {
public:
};

class DestructorDecl : public MethodDecl {
public:
};

} // namespace syn
} // namespace stone
#endif
