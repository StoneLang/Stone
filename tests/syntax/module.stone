module Stone.Physics; 


space Stone.Physics.Mechanics {
	public fun Fire(const Projectile* projectile = null) -> bool {
		return true; 
	}
}

space Stone.Physics.Quantum {

	struct ParticleProfile {
		public f32 mass; 
		public string name; 
	}
	public interface Particle {
		fun Fire() -> auto;  
	}	
	struct Proton : Particle {
		ParticleProfile* profile = null;
	}
	init fun Proton::Init(const ParticleProfile* profile) {
		self.profile = profile; 
	}
	defer fun Proton::Defer() {
		free profile;
	}
	public fun Proton::GetProfile() -> ParticleProfile* {
		return profile;  
	}
	public fun Proton::Fire() -> auto {
		int* result = null;
		if(profile.mass > 10.00) {
		}
		return true;
	}

}


// You may want to consider:

// Physics.stone
module System.Physics;

public fun Fire(Particle* particle) -> bool {

	if(particle == null) {
		Panic("Could not create 'Particle'");
	}
	return false; 
}

// Main
use Stone.Core;
use Stone.Physics; 

fun Main() -> int {	
	Particle* particle = new Particle();
	Fire(particle);
	free particle; 

	return 0; 
}


// Update

// File Math.stone


space Stone.Math {
	
	public fun Cos() -> {
	}
	public fun Sine() -> {
	}
}

/// Creates Stone.Math.stonemodule  
use Stone.Math;  

