space System.Collection;

public any(T) interface Queue {
	fun Add(T* t) -> void; 
	fun Pop() -> T*; 
}

/// Consider using a struct 
any(T) class PriorityQueue : any(T) Queue {
}

fun PriorityQueue::Push(T* t) -> void {
}
fun PriorityQueue::Pop() -> T* {
}

space System.Physics;
use System.Collection; 

struct Particle {
}
fun Main() -> u8 {
	use(int) Queue* q0 = new PriorityQueue();
	q0.Push(23);

	Particle* p = new Particle();
	real(string) Queue* q1 = new PriorityQueue(); 
	q1.Push(p);

	free {
		q0;
		q1;
		p;
	}
}

any(T) fun Max(T* first, T* second) -> T {
	if(first > second) {
		return first; 
	}
	return second;
}
auto max = use(i32) Max(23, 25); 

// Other way to tink about this

public interface Queue::(T) {
	fun Add(T* t) -> void; 
	fun Pop() -> T*; 
}
class PriorityQueue : Queue::(PriorityQueue) {
}

fun Main() {
	Queue::(Particle)* q = new PriorityQueue(); 
}

fun Queue::Push(T t) -> void {


}
